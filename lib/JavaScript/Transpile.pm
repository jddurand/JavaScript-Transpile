use strict;
use warnings FATAL => 'all';

package JavaScript::Transpile;

# ABSTRACT: Transpilation of JavaScript

use Carp qw/croak/;
use MarpaX::Languages::ECMAScript::AST qw//;
use Digest::MD4 qw/md4_hex/;
use CHI;
use File::HomeDir;
use Text::Xslate qw//;
use Scalar::Util qw/blessed/;
use Module::Util qw/find_installed/;
use File::Spec;
use File::Basename qw/dirname/;
use version 0.77;
use Log::Any qw/$log/;

our $distname = __PACKAGE__;
$distname =~ s/::/-/g;

our $CACHE = CHI->new(driver => 'File',
                      root_dir => File::HomeDir->my_dist_data($distname, { create => 1 } ),
                      label => __PACKAGE__,
                      namespace => 'cache',
		      max_key_length => 32);

# VERSION
our $CURRENTVERSION;
{
  #
  # Because $VERSION is generated by dzil, not available in dev. tree
  #
  no strict 'vars';
  $CURRENTVERSION = $VERSION;
}

=head1 DESCRIPTION

This module translates JavaScript (aka ECMAScript) source into another language.

=head1 SYNOPSIS

    use strict;
    use warnings FATAL => 'all';
    use JavaScript::Transpile;
    use Log::Log4perl qw/:easy/;
    use Log::Any::Adapter;
    use Log::Any qw/$log/;
    #
    # Init log
    #
    our $defaultLog4perlConf = '
    log4perl.rootLogger              = WARN, Screen
    log4perl.appender.Screen         = Log::Log4perl::Appender::Screen
    log4perl.appender.Screen.stderr  = 0
    log4perl.appender.Screen.layout  = PatternLayout
    log4perl.appender.Screen.layout.ConversionPattern = %d %-5p %6P %m{chomp}%n
    ';
    Log::Log4perl::init(\$defaultLog4perlConf);
    Log::Any::Adapter->set('Log4perl');
    #
    # Parse ECMAScript
    #
    my $ecmaSourceCode = 'var i = 0;';
    print JavaScript::Transpile->new()->transpile($ecmaSourceCode, target => 'perl5');

=head1 SUBROUTINES/METHODS

=head2 new($class, %options)

Instantiate a new object. Takes as parameter an optional hash of options that can be:

=over

=item cache

Produced transpilations can be cached: very often the same ECMAScript is used again and again, so there is no need to always transpile it at each call. The cache key is the buffer MD4 checksum, eventual collisions being handled. The cache location is the my_dist_data directory provided by File::HomeDir package. Default is a false value.

=item astCache

JavaScript::Transpile is using the ASTs produced by MarpaX::Languages::ECMAScript::AST, that have also a cache option. astCache correspond to the MarpaX::Languages::ECMAScript::AST cache option.

=item indent

Indent style. Default to 2 spaces.

=item newline

Newline style. Default to "\n".

=item space

Space style. Default to " ".

=back

=cut

# ----------------------------------------------------------------------------------------
sub new {
  my ($class, %opts) = @_;

  my $cache       = $opts{cache} // 0;
  my $astCache    = $opts{astCache}; # No pb if this is undef, we just proxy it
  my $indent      = $opts{indent} // '  ';
  my $newline     = $opts{newline} // "\n";
  my $space       = $opts{space} // " ";

  my $self  = {
      _cache       => $cache,
      _astCache    => $astCache,
      _indent      => $indent,
      _newline     => $newline,
      _space       => $space,
  };

  bless($self, $class);

  return $self;
}

# ----------------------------------------------------------------------------------------

=head2 parse($self, $source, %options)

Transpile an the ECMAScript source, pointed by $source, with the following options:

=over

=item grammarName

ECMAScript grammar version. Default is the one supplied with MarpaX::Languages::ECMAScript::AST.

=item target

Source language target. Default is 'perl5'.

=over

=cut

sub _blessed {
  my ($self, $ref) = @_;

  my $rc = blessed($ref) || '';
  $rc =~ s/.*:://;
  return $rc;
}

sub _lhs2lexeme {
  my ($self, $ref) = @_;
  my $rc = $ref->[0]->[2];
  #
  # C.f. "A little hack" section in the template
  #

  #print STDERR "_lhs2lexeme => $ref->[0]->[2]\n";


  $ref->[0]->[2] = '';
  return $rc;
}

sub _lexeme {
  my ($self, $ref) = @_;

  print STDERR "_lexeme($ref) => $ref->[2]\n";

  return $ref->[2];
}

sub _curIndent {
  my ($self) = @_;

  return $self->{_indent} x $self->{_curIndent};
}

sub _incIndent {
  my ($self) = @_;

  return $self->{_indent} x ++$self->{_curIndent};
}

sub _decIndent {
  my ($self) = @_;

  return $self->{_indent} x --$self->{_curIndent};
}

sub _newline {
  my ($self) = @_;

  return $self->{_newline};
}

sub _space {
  my ($self) = @_;

  return $self->{_space};
}

#
# Note: this will FAIL if the original source have 100 successive '{' - is thqt going to happen...
#
sub _flat {
  my ($self, $worklistp, $stopAtRcurlyb) = @_;

  $stopAtRcurlyb //= 0;
  my @flat = ();
  my $prev = '';
  do {
    my $obj = shift @{$worklistp};
    my $ref_type = ref $obj;
    if (! $self->_blessed($obj) && $ref_type eq 'ARRAY') {
      $prev = $obj->[2];
      if ($prev eq '{') {
        push(@flat, $prev, $self->_flat($worklistp, 1));
      }
      elsif ($prev eq '}' && $stopAtRcurlyb) {
        #
        # Push back the rcurly for our caller and remove it from our list
        #
        return( [ @flat ], $prev);
      } else {
        push(@flat, $prev);
      }
    }
    if (blessed($obj) || $ref_type eq 'ARRAY') {
      unshift(@{$worklistp}, @{$obj});
    }
  } while (@{$worklistp});

  return [ @flat ];
}

sub _render {
    my ($self, $lexemeArrayp, $recursiveb) = @_;

    #
    # This can be true only when called within the template
    #
    $recursiveb //= 1;

    $self->{_curIndent} += $recursiveb;

    my $rc = $self->{_tx}->render($self->{_targettx},
                                  {
                                   self         => $self,
                                   lexemeArrayp => $recursiveb ? [ @{$lexemeArrayp}] : $lexemeArrayp,
                                  }
                                 );

    my $indent = $self->{_indent} x $self->{_curIndent};

    $rc =~ s/^/$indent/smg;

    $self->{_curIndent} -= $recursiveb;

    return $rc;
}

sub _ast {
    my ($self, $source) = @_;

    return MarpaX::Languages::ECMAScript::AST->new(cache => $self->{_astCache}, grammarName => $self->{_grammarName})->parse($source);
}

sub _trace {
  my ($self, @args) = @_;

  print STDERR "@args\n"
}

sub _isArray {
  my ($self, $obj) = @_;

  return (ref($obj) eq 'ARRAY');
}

sub _getAndCheckHashFromCache {
  my ($self, $md4, $source, $transpilep, $fromCachep) = @_;

  my $rc = 0;

  my $fromCache = $CACHE->get($md4);
  if (defined($fromCache)) {
    my $clearCache = 1;
    my $store;
    if (ref($fromCache) eq 'HASH') {
      $store = $fromCache->{$source};
      if (defined($store)) {
        if (ref($store) eq 'HASH') {
          my $storeVersion = $store->{version};
          #
          # Trying to get from cache using the dev files will always clear the cache -;
          #
          if (defined($storeVersion) && defined($CURRENTVERSION)) {
            if (version::is_lax($storeVersion) && version::is_lax($CURRENTVERSION)) {
              if (version->parse($storeVersion) == version->parse($CURRENTVERSION)) {
                my $transpile = $store->{transpile};
                if (defined($transpile)) {
                  $log->tracef('cache ok, storeVersion=%s', $storeVersion);
                  $rc = 1;
                  ${$transpilep} = $transpile;
                  ${$fromCachep} = $fromCache;
                  $clearCache = 0;
                } else {
                  $log->tracef('cache ko, transpile undefined');
                }
              } else {
                $log->tracef('cache ko, storeVersion %s != %s (current version)', $storeVersion, $CURRENTVERSION);
              }
            } else {
              #
              # In case versions are really garbled, use %s instead of %d
              #
              $log->tracef('cache ko, storeVersion %s (is_lax=%s), current version %s (is_lax=%s)', $storeVersion, version::is_lax($storeVersion) || '', $CURRENTVERSION, version::is_lax($CURRENTVERSION) || '');
            }
          } else {
            $log->tracef('cache ko, storeVersion %s, current version %s', $storeVersion || 'undefined', $CURRENTVERSION || 'undefined');
          }
        } else {
          $log->tracef('cache ko, store is a %s', ref($store));
        }
      } else {
        $log->tracef('cache ko, no entry for given source code');
      }
    } else {
      $log->tracef('cache ko, $fromCache is a %s', ref($fromCache));
    }
    if ($clearCache) {
      if (ref($fromCache) eq 'HASH') {
        #
        # Invalid data
        #
        if (defined($store)) {
          delete($fromCache->{$source});
          $CACHE->set($md4, $fromCache);
          $log->tracef('cache cleaned');
        }
      } else {
        #
        # Invalid cache
        #
        $CACHE->remove($md4);
        $log->tracef('cache removed');
      }
    }
  } else {
    $log->tracef('cache ko, no cache for md4 %s', $md4);
  }

  return $rc;
}

sub parse {
  my ($self, $source, %options) = @_;

  my $target = $options{target} || 'perl5';

  my $file_system_path = find_installed(__PACKAGE__);
  my $tx = Text::Xslate->new(type => 'text',
			     path => File::Spec->catdir(dirname($file_system_path), 'Transpile', 'Xslate'),
			     function => {
                                          _isArray => \&_isArray,
                                          _render  => \&_render,
			     },
      );

  my $rc;
  $self->{_curIndent} = 0;
  $self->{_tx} = $tx;
  $self->{_targettx} = "$target.tx";
  #
  # If cache is enabled, compute the MD4 and check availability
  #
  my $transpile;
  if ($self->{_cache}) {
    my $md4 = md4_hex($source);
    my $fromCache = {};
    if (! $self->_getAndCheckHashFromCache($md4, $source, \$transpile, \$fromCache)) {
      $transpile = $self->_render($self->_flat([ $self->_ast($source) ]), 0);
      if (defined($CURRENTVERSION)) {
        $fromCache->{$source} = {transpile => $transpile, version => $CURRENTVERSION};
        $CACHE->set($md4, $fromCache);
      }
    }
  } else {
    $transpile = $self->_render($self->_flat([ $self->_ast($source) ]), 0);
  }

  delete($self->{_targettx});
  delete($self->{_tx});
  delete($self->{_curIndent});

  return $transpile;
}

=head1 SEE ALSO

L<Log::Any>, L<MarpaX::Languages::ECMAScript::AST>, L<Digest::MD4>, L<CHI::Driver::File>

=cut

1;
